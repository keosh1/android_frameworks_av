From 2f672ba0a741797490f5b54da84e611306757962 Mon Sep 17 00:00:00 2001
From: HELLBOY017 <abhaygill017@gmail.com>
Date: Tue, 24 May 2022 10:46:29 +0530
Subject: [PATCH 2/6] Add AC4Tbl params for dolby AC4 decoder [1/2]

Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
Signed-off-by: tejas101k <tejassingh649@rediffmail.com>
---
 media/libstagefright/ACodec.cpp           |  65 ++++
 media/libstagefright/Android.bp           |   1 +
 media/libstagefright/TableXInit.cpp       | 100 ++++++
 media/libstagefright/include/TableXInit.h | 186 ++++++++++
 media/libstagefright/omx/Android.bp       |   1 +
 media/libstagefright/omx/generic_header.h | 161 +++++++++
 media/libstagefright/omx/generic_source.c | 392 ++++++++++++++++++++++
 7 files changed, 906 insertions(+)
 create mode 100755 media/libstagefright/TableXInit.cpp
 create mode 100755 media/libstagefright/include/TableXInit.h
 create mode 100755 media/libstagefright/omx/generic_header.h
 create mode 100755 media/libstagefright/omx/generic_source.c

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index e06efac6df2..73b1e59acef 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -66,6 +66,7 @@
 #include "include/SecureBuffer.h"
 #include "include/SharedMemoryBuffer.h"
 #include <media/stagefright/omx/OMXUtils.h>
+#include "TableXInit.h"
 
 #include <server_configurable_flags/get_flags.h>
 
@@ -3143,6 +3144,27 @@ status_t ACodec::setupEAC3Codec(
             (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidEac3, &def, sizeof(def));
 }
 
+
+template<class T>
+static void InitTblOMXParams(T *params) {
+    params->nSize = sizeof(T);
+    params->seedA = 0;
+    params->seedB = 0;
+    params->seedC = 0;
+
+    params->idA = 0;
+    params->idB = 0;
+    params->idC = 0;
+
+    params->maskA = 0;
+    params->maskB = 0;
+    params->maskC = 0;
+
+    params->sizeA = 0;
+    params->sizeB = 0;
+    params->sizeC = 0;
+}
+
 status_t ACodec::setupAC4Codec(
         bool encoder, int32_t numChannels, int32_t sampleRate) {
     status_t err = setupRawAudioFormat(
@@ -3170,6 +3192,49 @@ status_t ACodec::setupAC4Codec(
 
     def.nChannels = numChannels;
     def.nSampleRate = sampleRate;
+    
+    OMX_AUDIO_PARAM_ANDROID_AC4TBL tbl;
+    InitTblOMXParams(&tbl);
+
+    TableXInit *A_OBJ = new TableXInit(AC4_TABLE_SEC_FRS_CODE,
+                                       AC4_TABLE_SEC_FRS_MASK_VAL);
+
+    TableXInit *B_OBJ = new TableXInit(AC4_TABLE_SEC_MDD_MAX_FRAM,
+                                       AC4_TABLE_SEC_MMF_MASK_VAL);
+
+    TableXInit *C_OBJ = new TableXInit(AC4_TABLE_SEC_MDD_MAX_INST,
+                                       AC4_TABLE_SEC_MMI_MASK_VAL);
+
+    A_OBJ->init();
+    B_OBJ->init();
+    C_OBJ->init();
+
+    tbl.seedA = A_OBJ->getSeed();
+    tbl.seedB = B_OBJ->getSeed();
+    tbl.seedC = C_OBJ->getSeed();
+
+    tbl.sizeA = A_OBJ->getSize();
+    tbl.sizeB = B_OBJ->getSize();
+    tbl.sizeC = C_OBJ->getSize();
+
+    tbl.idA = A_OBJ->getTableID();
+    tbl.idB = B_OBJ->getTableID();
+    tbl.idC = C_OBJ->getTableID();
+
+    tbl.maskA = A_OBJ->getMaskVal();
+    tbl.maskB = B_OBJ->getMaskVal();
+    tbl.maskC = C_OBJ->getMaskVal();
+
+    memcpy (tbl.bufferA, A_OBJ->getBuffer(), LUT_BUFFER_SIZE);
+    memcpy (tbl.bufferB, B_OBJ->getBuffer(), TABLE_B_C_U8_SZ);
+    memcpy (tbl.bufferC, C_OBJ->getBuffer(), TABLE_B_C_U8_SZ);
+
+    mOMXNode->setParameter(
+            (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAc4Tbl, &tbl, sizeof(tbl));
+
+    delete A_OBJ;
+    delete B_OBJ;
+    delete C_OBJ;
 
     return mOMXNode->setParameter(
             (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAc4, &def, sizeof(def));
diff --git a/media/libstagefright/Android.bp b/media/libstagefright/Android.bp
index 746dc2c1114..161dc29fcd2 100644
--- a/media/libstagefright/Android.bp
+++ b/media/libstagefright/Android.bp
@@ -271,6 +271,7 @@ cc_library {
         "StagefrightMediaScanner.cpp",
         "SurfaceMediaSource.cpp",
         "SurfaceUtils.cpp",
+        "TableXInit.cpp" ,
         "ThrottledSource.cpp",
         "Utils.cpp",
         "VideoFrameSchedulerBase.cpp",
diff --git a/media/libstagefright/TableXInit.cpp b/media/libstagefright/TableXInit.cpp
new file mode 100755
index 00000000000..f29bce9095f
--- /dev/null
+++ b/media/libstagefright/TableXInit.cpp
@@ -0,0 +1,100 @@
+/******************************************************************************
+ * This program is protected under international and U.S. copyright laws as
+ * an unpublished work. This program is confidential and proprietary to the
+ * copyright owners. Reproduction or disclosure, in whole or in part, or the
+ * production of derivative works therefrom without the express permission of
+ * the copyright owners is prohibited.
+ *
+ *              Copyright (C) 2017 by Dolby International AB.
+ *                            All rights reserved.
+ ******************************************************************************/
+
+#include <ctime>
+#include <cstdlib>
+
+#include "include/TableXInit.h"
+
+namespace android {
+
+TableXInit::TableXInit(uint8_t table_id, uint8_t mask_val)
+     :_table_id(table_id),
+      _mask_val(mask_val),
+      _session_seed(rand()),
+      _buffer_size(0),
+      _isTableXInitialized(0)
+{
+    for (unsigned int i = 0; i < MAX_BUFFER_SIZE; i++) {
+        _buffer[i] = 0;
+    }
+}
+
+void
+TableXInit::init()
+{
+    union SCRAMBLED_TABLE_PT
+    {
+        unsigned char  *ui8;
+        unsigned int   *ui32;
+    } scramble_table_pt;
+
+    scramble_table_pt.ui32 = scrambled_table;
+
+    if (   _table_id == AC4_TABLE_SEC_FRS_CODE
+        && _isTableXInitialized == 0 )
+    {
+
+        _buffer_size = LUT_BUFFER_SIZE;
+
+        for(unsigned int i = 0; i < _buffer_size; i++)
+        {
+            _buffer[i] = _table_a_u8[i] ^ (  scramble_table_pt.ui8[ ( i + _session_seed ) % LUT_BUFFER_SIZE]
+                                            ^ scramble_table_pt.ui8[ ( i + _session_seed + _mask_val) % LUT_BUFFER_SIZE] );
+        }
+        _isTableXInitialized = 1;
+    }
+    else
+    if (   _table_id == AC4_TABLE_SEC_MDD_MAX_FRAM
+        && _isTableXInitialized == 0 )
+    {
+        _buffer_size = TABLE_B_C_U8_SZ;
+
+        for(unsigned int i = 0; i < _buffer_size; i++)
+        {
+            _buffer[i] = _table_b_u8[i] ^ (  scramble_table_pt.ui8[ ( i + _session_seed ) % LUT_BUFFER_SIZE]
+                                           ^ scramble_table_pt.ui8[ ( i + _session_seed + _mask_val ) % LUT_BUFFER_SIZE] );
+        }
+        _isTableXInitialized = 1;
+    }
+    else
+    if (   _table_id == AC4_TABLE_SEC_MDD_MAX_INST
+        && _isTableXInitialized == 0 )
+    {
+
+        _buffer_size = TABLE_B_C_U8_SZ;
+
+        for(unsigned int i = 0; i < _buffer_size; i++)
+        {
+            _buffer[i] = _table_c_u8[i] ^ (  scramble_table_pt.ui8[ ( i + _session_seed ) % LUT_BUFFER_SIZE]
+                                           ^ scramble_table_pt.ui8[ ( i + _session_seed + _mask_val ) % LUT_BUFFER_SIZE] );
+        }
+        _isTableXInitialized = 1;
+    }
+}
+
+TableXInit::~TableXInit()
+{
+    _session_seed = 0;
+    _table_id     = 0;
+    _mask_val     = 0;
+    _buffer_size  = 0;
+
+    _isTableXInitialized = 0;
+
+    for (int i = 0; i < MAX_BUFFER_SIZE; i++)
+    {
+        _buffer[i] = 0;
+    }
+}
+
+}; // namespace
+
diff --git a/media/libstagefright/include/TableXInit.h b/media/libstagefright/include/TableXInit.h
new file mode 100755
index 00000000000..4b832aafb62
--- /dev/null
+++ b/media/libstagefright/include/TableXInit.h
@@ -0,0 +1,186 @@
+/******************************************************************************
+ * This program is protected under international and U.S. copyright laws as
+ * an unpublished work. This program is confidential and proprietary to the
+ * copyright owners. Reproduction or disclosure, in whole or in part, or the
+ * production of derivative works therefrom without the express permission of
+ * the copyright owners is prohibited.
+ *
+ *              Copyright (C) 2017 by Dolby International AB.
+ *                            All rights reserved.
+ ******************************************************************************/
+
+/**
+ * @brief For the AC-4 Split Security solution, setup the session
+ *        parameters for table retrieval
+ *
+ * @return DLB_AC4DEC_OK on success
+ */
+
+#ifndef TABLEXINIT_H
+#define TABLEXINIT_H
+
+#include <iostream>
+#include <memory>
+
+/* Put in macro here */
+
+#define LUT_BUFFER_SIZE             (256)
+#define MAX_BUFFER_SIZE             LUT_BUFFER_SIZE
+
+#define TABLE_B_C_U8_SZ             (80)
+#define TABLE_A_U32_SZ              (64)
+
+/* Table Identifiers */
+#define AC4_TABLE_SEC_FRS_CODE      0x09
+#define AC4_TABLE_SEC_MDD_MAX_FRAM  0x0A
+#define AC4_TABLE_SEC_MDD_MAX_INST  0x0B
+
+/* Session Mask Parameters */
+#define AC4_TABLE_SEC_FRS_MASK_VAL  0x0
+#define AC4_TABLE_SEC_MMF_MASK_VAL  0x4
+#define AC4_TABLE_SEC_MMI_MASK_VAL  0x8
+
+static unsigned char _table_a_u8[LUT_BUFFER_SIZE] = {
+
+/*0*/  0x7F,0xF8,0xFF,0xFF, 0xFC,0xFF,0xFF,0xFF, 0xF5,0xFF,0xFF,0xFF, 0xFD,0xFF,0xFF,0xFF,
+/*1*/  0x7F,0xF8,0xFF,0xFF, 0xFC,0xFF,0xFF,0xFF, 0xF5,0xFF,0xFF,0xFF, 0xFE,0xFF,0xFF,0xFF,
+/*2*/  0xFF,0xF7,0xFF,0xFF, 0xFB,0xFF,0xFF,0xFF, 0xF7,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF,
+/*3*/  0xFF,0xF9,0xFF,0xFF, 0xF9,0xFF,0xFF,0xFF, 0xFB,0xFF,0xFF,0xFF, 0xFD,0xFF,0xFF,0xFF,
+/*4*/  0xFF,0xF9,0xFF,0xFF, 0xF9,0xFF,0xFF,0xFF, 0xFB,0xFF,0xFF,0xFF, 0xFE,0xFF,0xFF,0xFF,
+/*5*/  0x3F,0xFC,0xFF,0xFF, 0xFC,0xFF,0xFF,0xFF, 0xFA,0xFF,0xFF,0xFF, 0xFD,0xFF,0xFF,0xFF,
+/*6*/  0x3F,0xFC,0xFF,0xFF, 0xFC,0xFF,0xFF,0xFF, 0xFA,0xFF,0xFF,0xFF, 0xFE,0xFF,0xFF,0xFF,
+/*7*/  0xFF,0xFB,0xFF,0xFF, 0xFB,0xFF,0xFF,0xFF, 0xFB,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF,
+/*8*/  0xFF,0xFC,0xFF,0xFF, 0xF9,0xFF,0xFF,0xFF, 0xFD,0xFF,0xFF,0xFF, 0xFD,0xFF,0xFF,0xFF,
+/*9*/  0xFF,0xFC,0xFF,0xFF, 0xF9,0xFF,0xFF,0xFF, 0xFD,0xFF,0xFF,0xFF, 0xFE,0xFF,0xFF,0xFF,
+/*10*/ 0xFF,0xFD,0xFF,0xFF, 0xFB,0xFF,0xFF,0xFF, 0xFD,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF,
+/*11*/ 0x7F,0xFE,0xFF,0xFF, 0xF9,0xFF,0xFF,0xFF, 0xFE,0xFF,0xFF,0xFF, 0xFD,0xFF,0xFF,0xFF,
+/*12*/ 0x7F,0xFE,0xFF,0xFF, 0xF9,0xFF,0xFF,0xFF, 0xFE,0xFF,0xFF,0xFF, 0xFE,0xFF,0xFF,0xFF,
+/*13*/ 0xFF,0xF7,0xFF,0xFF, 0xFB,0xFF,0xFF,0xFF, 0xF7,0xFF,0xFF,0xFF, 0xF9,0xFF,0xFF,0xFF,
+/*14*/ 0xFF,0xF7,0xFF,0xFF, 0xFB,0xFF,0xFF,0xFF, 0xF7,0xFF,0xFF,0xFF, 0xFC,0xFF,0xFF,0xFF,
+/*15*/ 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFA,0xFF,0xFF,0xFF
+};
+
+static unsigned char _table_b_u8[LUT_BUFFER_SIZE] = {
+/*0*/  0xF7,0xFF,0xFF,0xFF,
+/*1*/  0xFA,0xFF,0xFF,0xFF,
+/*2*/  0xFA,0xFF,0xFF,0xFF,
+/*3*/  0xFA,0xFF,0xFF,0xFF,
+/*4*/  0xFA,0xFF,0xFF,0xFF,
+/*5*/  0xFA,0xFF,0xFF,0xFF,
+/*6*/  0xFA,0xFF,0xFF,0xFF,
+/*7*/  0xFA,0xFF,0xFF,0xFF,
+/*8*/  0xFA,0xFF,0xFF,0xFF,
+/*9*/  0xFA,0xFF,0xFF,0xFF,
+/*10*/ 0xFA,0xFF,0xFF,0xFF,
+/*11*/ 0xFA,0xFF,0xFF,0xFF,
+/*12*/ 0xFA,0xFF,0xFF,0xFF,
+/*13*/ 0xFA,0xFF,0xFF,0xFF,
+/*14*/ 0xFA,0xFF,0xFF,0xFF,
+/*15*/ 0xFA,0xFF,0xFF,0xFF,
+/*16*/ 0xFA,0xFF,0xFF,0xFF,
+/*17*/ 0xF7,0xFF,0xFF,0xFF,
+/*18*/ 0xF7,0xFF,0xFF,0xFF,
+/*19*/ 0xFA,0xFF,0xFF,0xFF,
+};
+
+static unsigned char _table_c_u8[TABLE_B_C_U8_SZ] = {
+/*0*/  0xFE, 0xFF, 0xFF, 0xFF,
+/*1*/  0xFE, 0xFF, 0xFF, 0xFF,
+/*2*/  0xF4, 0xFF, 0xFF, 0xFF,
+/*3*/  0xF4, 0xFF, 0xFF, 0xFF,
+/*4*/  0xF4, 0xFF, 0xFF, 0xFF,
+/*5*/  0xFA, 0xFF, 0xFF, 0xFF,
+/*6*/  0xFA, 0xFF, 0xFF, 0xFF,
+/*7*/  0xFE, 0xFF, 0xFF, 0xFF,
+/*8*/  0xFC, 0xFF, 0xFF, 0xFF,
+/*9*/  0xFE, 0xFF, 0xFF, 0xFF,
+/*10*/ 0xFD, 0xFF, 0xFF, 0xFF,
+/*11*/ 0xFD, 0xFF, 0xFF, 0xFF,
+/*12*/ 0xFE, 0xFF, 0xFF, 0xFF,
+/*13*/ 0xFE, 0xFF, 0xFF, 0xFF,
+/*14*/ 0xFE, 0xFF, 0xFF, 0xFF,
+/*15*/ 0xFE, 0xFF, 0xFF, 0xFF,
+/*16*/ 0xF4, 0xFF, 0xFF, 0xFF,
+/*17*/ 0xFE, 0xFF, 0xFF, 0xFF,
+/*18*/ 0xFE, 0xFF, 0xFF, 0xFF,
+/*19*/ 0xFE, 0xFF, 0xFF, 0xFF
+};
+
+static unsigned int scrambled_table[TABLE_A_U32_SZ] = {
+      0x18aa9205,0xb9953de4,0x6fc38e9e,0x6c44fe69,
+      0x2dcf9356,0x0755aed1,0xf994015f,0x28dc5d10,
+      0x0efc3170,0x2486ce80,0x1a4f683a,0xda7ea9bf,
+      0xba6747ab,0x65cc8474,0x1b3049af,0xd89d380f,
+      0x1535e9e3,0xb4d4ace6,0xbce2eb58,0xa7627839,
+      0x21cb3cf3,0x2b52bd11,0x9023a173,0xd9793f51,
+      0x22d3767f,0xf487f17a,0x40b02606,0x97d25c0d,
+      0x2a6e4de7,0xb699dbb3,0xb15a64a8,0x539f00e0,
+      0x43ea19cd,0x6dc24617,0x0298c027,0x50c13ed6,
+      0x6b2c16d5,0xdf13710b,0xbee575ad,0x964863f5,
+      0xfb29917c,0xec3461b5,0xca36b74a,0x5466a2bb,
+      0x088104f6,0x2f8f7bb2,0x9c0cf233,0x208b7d8c,
+      0x881d4ea5,0x6077144c,0xff0aa4ef,0x25de45e8,
+      0xddb85985,0x5ed009a6,0xc8c5c6ed,0x2e82f7d7,
+      0x4172a3fa,0x576ac4f0,0x37e18d1e,0xfd12034b,
+      0x5bf8421c,0x9b1f9a83,0x3ba0c7c9,0x32898aee
+};
+
+// ---------------------------------------------------------------------------
+
+namespace android {
+
+class TableXInit
+{
+public:
+    /*!
+     * Constructors and destructors
+     */
+    TableXInit(unsigned char table_id, unsigned char mask_val = 0);
+    ~TableXInit();
+
+    unsigned char getSeed()
+    {
+        return _session_seed;
+    }
+
+    unsigned char * getBuffer()
+    {
+        return _buffer;
+    }
+
+    unsigned char getTableID()
+    {
+       return _table_id;
+    }
+
+    unsigned char getMaskVal()
+    {
+       return _mask_val;
+    }
+
+    unsigned int getSize()
+    {
+       return _buffer_size;
+    }
+
+    unsigned char isInit()
+    {
+        return _isTableXInitialized;
+    }
+
+    void init();
+
+private:
+    unsigned char _table_id;
+    unsigned char _mask_val;
+    unsigned char _session_seed;
+    unsigned int  _buffer_size;
+
+    unsigned char _isTableXInitialized;
+
+    unsigned char _buffer[MAX_BUFFER_SIZE];
+};
+
+}; //namespace
+
+#endif //TABLEXINIT_H
diff --git a/media/libstagefright/omx/Android.bp b/media/libstagefright/omx/Android.bp
index 630817c7e66..c7d5a1f3c9f 100644
--- a/media/libstagefright/omx/Android.bp
+++ b/media/libstagefright/omx/Android.bp
@@ -33,6 +33,7 @@ cc_library_shared {
         "1.0/WOmxNode.cpp",
         "1.0/WOmxObserver.cpp",
         "1.0/WOmxBufferSource.cpp",
+        "generic_source.c"
     ],
 
     export_include_dirs: [
diff --git a/media/libstagefright/omx/generic_header.h b/media/libstagefright/omx/generic_header.h
new file mode 100755
index 00000000000..e5b49defc09
--- /dev/null
+++ b/media/libstagefright/omx/generic_header.h
@@ -0,0 +1,161 @@
+/******************************************************************************
+ * This program is protected under international and U.S. copyright laws as
+ * an unpublished work. This program is confidential and proprietary to the
+ * copyright owners. Reproduction or disclosure, in whole or in part, or the
+ * production of derivative works therefrom without the express permission of
+ * the copyright owners is prohibited.
+ *
+ *                Copyright (C) 2017 by Dolby International AB.
+ *                            All rights reserved.
+ ******************************************************************************/
+
+/**
+ * @addtogroup ac4dec_lib_cch Configuration Change Handler (CCH)
+ *
+ * @brief This module implements Part 2 of the AC-4 Split Security Architecture
+ *        This module implements the three functions that were identified as
+ *        part of the original TEE Architecture. All function names have been
+ *        renamed as generic_function_X
+ */
+
+/**
+ *  @file
+ *
+ *  @ingroup generic_shared_library
+ *
+ *  @brief AC-4 Split Security Architecture Shared Library Implementation.
+ *
+ */
+
+#ifndef GENERIC_HEADER_H
+#define GENERIC_HEADER_H
+
+#include <math.h>
+#include <float.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#define LOG_DUALIS_TABLE_SIZE   65   /**< Number of entries for ld(x) lookup table used by DLB_logDualisDiv8(x) */
+
+static float get_num_octaves_div8(unsigned int a, unsigned int b);
+unsigned int function_a (unsigned int sbx, unsigned int sbz);
+
+#define MAX_NUM_ASPX_INST_CHANNELS            2 /**< Maximum number of A-SPX channels per instance. */
+#define MAX_NUM_ATSG_SIG                      5 /**< Maximum number of signal time slot groups (signal envelopes) per A-SPX frame */
+#define MAX_NUM_ATSG_NOISE                    2 /**< Maximum number of noise time slot groups (noise envelopes) per A-SPX frame */
+#define MAX_NUM_SBG_SIG_HIRES                22 /**< Maximum number of signal QMF subband groups (scale factor bands) for high resolution */
+#define MAX_NUM_SBG_SIG_LORES                11 /**< Maximum number of signal QMF subband groups (scale factor bands) for low resolution */
+#define MAX_NUM_SBG_NOISE                     5 /**< Maximum number of noise QMF subband groups (scale factor bands) */
+#define MAX_NUM_SB_ASPX                      44 /**< Maximum number of QMF subbands in the A-SPX range */
+/** @brief Macro to retrieve the add harmonic flag for a specific A-SPX subband group from the respective bit field. */
+#define ADD_HARMONIC(bitfield, sbg) ((bitfield) & (0x1UL << ((sizeof(unsigned long)*CHAR_BIT-1)-(sbg))))
+
+/**
+ * @brief  Calculate sine start envelopes.
+ *
+ * The values in p_sine_start_env indicate the envelope numbers where sines have to start (per subband group).
+ * A value of MAX_NUM_ATSG_SIG indicates that no sine is present.
+ *
+ */
+void
+function_b
+    (unsigned int                       num_sbg_sig_highres     /**< [in]     Number high resolution subband groups. */
+    ,unsigned int                       aspx_sbg_start          /**< [in]     A-SPX start subband group. */
+    ,signed int                         aspx_tsg_ptr            /**< [in]     Pointer to envelope border signalling sine start
+                                                                              envelope */
+    ,unsigned long                      aspx_add_harmonic       /**< [in]     Sinusoid insertion flags (one bit per sbg). */
+    ,unsigned int                      *p_sine_start_env        /**< [in,out] An array indicating the sine start envelope per
+                                                                              subband group. */
+    );
+
+
+#define GET_CONFIG_EVENT(config_change)               \
+    (cch_config_change_t)((config_change) & 0x0F)
+
+#define GET_FRAME_EVENT(config_change)                \
+    (cch_config_change_t)((config_change) & 0xF0)
+#define SET_CONFIG_EVENT(config_change, config_event) \
+    (config_change = (cch_config_change_t)(((config_change) & 0xF0) | config_event))
+
+#define SET_FRAME_EVENT(config_change, frame_event)   \
+    (config_change = (cch_config_change_t)(((config_change) & 0x0F) | frame_event))
+
+/**
+ * @brief Configuration change information.
+ *
+ * Please note, that the order of the messages does matter.
+ */
+typedef enum
+{
+    UNDEFINED          = -1
+
+    /* lower nibble reserved for configuration event messages */
+   ,NO_CHANGE          = 0x00 /* Nothing changed, normal processing. */
+   ,SEAMLESS           = 0x01 /* Perfect transition, only used in combination with frame rate switches between multiples. */
+   ,GAPLESS            = 0x02 /* No silence gap in between. */
+   ,CLEAN              = 0x03 /* Something better than GAPLESS but not as good as SEAMLESS, still needs to be defined. */
+   ,SPLICE             = 0x04 /* A SPLICE always introduces silence gaps. */
+
+    /* upper nibble reserved for frame event messages */
+   ,FRAME_DROP         = 0x10
+   ,FRAME_REPETITION   = 0x20
+} cch_config_change_t;
+
+/**
+ * @brief Determines the slice index within an EHFR frame sequence.
+ *
+ * @return The slice index within an EHFR frame sequence.
+ */
+static inline unsigned int
+cch_get_slice_index
+    (unsigned int              sequence_counter               /**< [in] Sequence counter. */
+    ,unsigned int              frame_rate_fraction            /**< [in] Frame rate fraction. */
+    )
+{
+    return sequence_counter & (frame_rate_fraction - 1);
+}
+
+typedef struct cch_frame_data_s
+{
+    cch_config_change_t        config_change;                 /**< Configuration change.
+                                                                   Can be of types: NO_CHANGE, SEAMLESS, GAPLESS,
+                                                                   CLEAN, SPLICE, FRAME_DROP, FRAME_REPETITION */
+    int                        b_frame_complete;              /**< Flag indicating if the frame is complete and can be decoded. */
+    int                        b_collection_frame;            /**< Flag indicating a collection frame, i.e. the frame is not
+                                                                   processed but collected. */
+} cch_frame_data_t;
+
+/*
+ * Determines and assigns data to the frame data structure which exists for every single frame and is stored in the internal FIFO
+ * buffer. Moreover, the config_change message is complemented with a frame event (FRAME_DROP or FRAME_REPETITION).
+ * Note that short frame equivalents - as used for frame length information - means, that e.g. a long frame has the length of 4.
+ */
+int
+function_c
+    (int                       b_collection_frame_previous    /* [in] Flag indicating if the previous frame was a collection
+                                                                      frame. */
+    ,unsigned int              sequence_counter_current       /* [in] Sequence counter of current frame. */
+    ,unsigned int              frame_rate_fraction_previous   /* [in] Frame rate fraction of previous frame. */
+    ,unsigned int              frame_rate_fraction_current    /* [in] Frame rate fraction of current frame. */
+    ,unsigned int              length_frame_delayed           /* [in] Length of the delayed frame in units of short frame
+                                                                      equivalents. */
+    ,unsigned int              length_frame_current           /* [in] Length of the current frame in units of short frame
+                                                                      equivalents. */
+    ,cch_config_change_t      *p_config_change                /* [in,out] Configuration change. */
+    ,unsigned int             *p_length_frames_collected      /* [in,out] Stores the overall length of collected frames in units of
+                                                                          short frame equivalents.
+                                                                          This variable is updated within this function. */
+    ,unsigned int             *p_num_frames_collected         /* [in,out] Stores the number of collected frames during a
+                                                                          collection phase.
+                                                                          This variable is updated within this function. */
+    ,unsigned int             *p_num_slices_available         /* [in,out] Slice counter holding the number of available slices.
+                                                                          This variable is updated within this function. */
+    ,cch_config_change_t      *p_config_change_previous       /* [out] Config change of previous frame. */
+    ,cch_frame_data_t         *p_frame_data_current           /* [out] Frame data structure to be filled. */
+    );
+
+#else
+
+//#error "libstagefright: AC4 Split Security Architecture unsupported"
+
+#endif // GENERIC_HEADER_H
diff --git a/media/libstagefright/omx/generic_source.c b/media/libstagefright/omx/generic_source.c
new file mode 100755
index 00000000000..7b91dfd6480
--- /dev/null
+++ b/media/libstagefright/omx/generic_source.c
@@ -0,0 +1,392 @@
+/******************************************************************************
+ * This program is protected under international and U.S. copyright laws as
+ * an unpublished work. This program is confidential and proprietary to the
+ * copyright owners. Reproduction or disclosure, in whole or in part, or the
+ * production of derivative works therefrom without the express permission of
+ * the copyright owners is prohibited.
+ *
+ *              Copyright (C) 2017 by Dolby International AB.
+ *                            All rights reserved.
+ ******************************************************************************/
+
+/**
+ *  @file
+ *
+ *  @ingroup security_split
+ *
+ *  @brief A-SPX frequency scale calculation
+ */
+
+#include <math.h>
+
+#include "generic_header.h"
+
+#define LOG_TAG "generic_source"
+
+#define DLB_ScF(a) ((float)(a))
+static const float Q15 = 32768.0f;
+
+union float_long
+  {
+    float f;
+    long l;
+  };
+
+static long lmax(long a, long b) { return a < b ? b : a; }
+static long lmin(long a, long b) { return a < b ? a : b; }
+static long lclip(long a, long lo, long hi) { return lmin( lmax(a, lo), hi); }
+
+static int16_t
+DLB_16srndS(float a) {
+    return (int16_t)lclip(lrintf(Q15 * a), INT16_MIN, INT16_MAX); }
+
+static float
+DLB_SsubSS(float a, float b) {
+    return a - b; }
+
+#define shru(a, shift) ldexpf((a), -(int)(shift))
+static  float
+DLB_SshrSU(float a, unsigned sh) {
+    return shru(a, sh); }
+
+static const float a_log_dualis[LOG_DUALIS_TABLE_SIZE] = {
+    DLB_ScF(-1.00000000000),  /* actually, ld 0 is not defined */
+    DLB_ScF(0.000000000000),  /*  ld(1) / 8  */
+    DLB_ScF(0.125000000000),  /*  ld(2) / 8  */
+    DLB_ScF(0.198120312590),  /*  ld(3) / 8  */
+    DLB_ScF(0.250000000000),  /*  ld(4) / 8  */
+    DLB_ScF(0.290241011861),  /*  ld(5) / 8  */
+    DLB_ScF(0.323120312590),  /*  ld(6) / 8  */
+    DLB_ScF(0.350919365257),  /*  ld(7) / 8  */
+    DLB_ScF(0.375000000000),  /*  ld(8) / 8  */
+    DLB_ScF(0.396240625180),  /*  ld(9) / 8  */
+    DLB_ScF(0.415241011861),  /*  ld(10) / 8  */
+    DLB_ScF(0.432428952330),  /*  ld(11) / 8  */
+    DLB_ScF(0.448120312590),  /*  ld(12) / 8  */
+    DLB_ScF(0.462554964768),  /*  ld(13) / 8  */
+    DLB_ScF(0.475919365257),  /*  ld(14) / 8  */
+    DLB_ScF(0.488361324451),  /*  ld(15) / 8  */
+    DLB_ScF(0.500000000000),  /*  ld(16) / 8  */
+    DLB_ScF(0.510932855156),  /*  ld(17) / 8  */
+    DLB_ScF(0.521240625180),  /*  ld(18) / 8  */
+    DLB_ScF(0.530990939180),  /*  ld(19) / 8  */
+    DLB_ScF(0.540241011861),  /*  ld(20) / 8  */
+    DLB_ScF(0.549039677847),  /*  ld(21) / 8  */
+    DLB_ScF(0.557428952330),  /*  ld(22) / 8  */
+    DLB_ScF(0.565445244507),  /*  ld(23) / 8  */
+    DLB_ScF(0.573120312590),  /*  ld(24) / 8  */
+    DLB_ScF(0.580482023722),  /*  ld(25) / 8  */
+    DLB_ScF(0.587554964768),  /*  ld(26) / 8  */
+    DLB_ScF(0.594360937770),  /*  ld(27) / 8  */
+    DLB_ScF(0.600919365257),  /*  ld(28) / 8  */
+    DLB_ScF(0.607247624391),  /*  ld(29) / 8  */
+    DLB_ScF(0.613361324451),  /*  ld(30) / 8  */
+    DLB_ScF(0.619274538798),  /*  ld(31) / 8  */
+    DLB_ScF(0.625000000000),  /*  ld(32) / 8  */
+    DLB_ScF(0.630549264920),  /*  ld(33) / 8  */
+    DLB_ScF(0.635932855156),  /*  ld(34) / 8  */
+    DLB_ScF(0.641160377118),  /*  ld(35) / 8  */
+    DLB_ScF(0.646240625180),  /*  ld(36) / 8  */
+    DLB_ScF(0.651181670704),  /*  ld(37) / 8  */
+    DLB_ScF(0.655990939180),  /*  ld(38) / 8  */
+    DLB_ScF(0.660675277358),  /*  ld(39) / 8  */
+    DLB_ScF(0.665241011861),  /*  ld(40) / 8  */
+    DLB_ScF(0.669694000577),  /*  ld(41) / 8  */
+    DLB_ScF(0.674039677847),  /*  ld(42) / 8  */
+    DLB_ScF(0.678283094338),  /*  ld(43) / 8  */
+    DLB_ScF(0.682428952330),  /*  ld(44) / 8  */
+    DLB_ScF(0.686481637041),  /*  ld(45) / 8  */
+    DLB_ScF(0.690445244507),  /*  ld(46) / 8  */
+    DLB_ScF(0.694323606460),  /*  ld(47) / 8  */
+    DLB_ScF(0.698120312590),  /*  ld(48) / 8  */
+    DLB_ScF(0.701838730514),  /*  ld(49) / 8  */
+    DLB_ScF(0.705482023722),  /*  ld(50) / 8  */
+    DLB_ScF(0.709053167746),  /*  ld(51) / 8  */
+    DLB_ScF(0.712554964768),  /*  ld(52) / 8  */
+    DLB_ScF(0.715990056820),  /*  ld(53) / 8  */
+    DLB_ScF(0.719360937770),  /*  ld(54) / 8  */
+    DLB_ScF(0.722669964191),  /*  ld(55) / 8  */
+    DLB_ScF(0.725919365257),  /*  ld(56) / 8  */
+    DLB_ScF(0.729111251771),  /*  ld(57) / 8  */
+    DLB_ScF(0.732247624391),  /*  ld(58) / 8  */
+    DLB_ScF(0.735330381170),  /*  ld(59) / 8  */
+    DLB_ScF(0.738361324451),  /*  ld(60) / 8  */
+    DLB_ScF(0.741342167195),  /*  ld(61) / 8  */
+    DLB_ScF(0.744274538798),  /*  ld(62) / 8  */
+    DLB_ScF(0.747159990437),  /*  ld(63) / 8  */
+    DLB_ScF(0.750000000000)   /*  ld(64) / 8  */
+};
+
+
+/**
+   @brief   Scaled Logarithm dualis by table lookup
+
+   The valid range for a is 1 to LOG_DUALIS_TABLE_SIZE.
+   For a=0, the result will be -1 (should be -inf).
+
+   @return   ld(a) / 8
+*/
+static inline float
+log_dualis_div8
+    (unsigned int a  /**< Index for logarithm table */
+    )
+{
+    //DLB_assert(a<LOG_DUALIS_TABLE_SIZE, "ASPX", "Index for a_log_dualis[] out of range.");
+    return a_log_dualis[a];
+}
+
+
+/**
+   @brief   Get number of octaves between frequencies a and b
+
+   The Result is scaled with 1/8.
+   The valid range for a and b is 1 to LOG_DUALIS_TABLE_SIZE.
+
+   @return   ld(a/b) / 8
+*/
+static float get_num_octaves_div8(unsigned int a  /**< lower band */
+                                      ,unsigned int b  /**< upper band */
+                                       )
+{
+    return DLB_SsubSS(log_dualis_div8(b), log_dualis_div8(a));
+}
+
+unsigned int function_a (unsigned int sbx, unsigned int sbz)
+{
+    return (unsigned)DLB_16srndS(DLB_SshrSU((get_num_octaves_div8(sbx, sbz)), 2));
+
+}
+
+void
+function_b
+    (unsigned int                       num_sbg_sig_highres
+    ,unsigned int                       aspx_sbg_start
+    ,signed int                         aspx_tsg_ptr
+    ,unsigned long                      aspx_add_harmonic
+    ,unsigned int                      *p_sine_start_env
+    )
+{
+    unsigned int sbg;
+    unsigned int aspx_sbg_stop = aspx_sbg_start + num_sbg_sig_highres;
+
+    //DLB_assert(aspx_sbg_stop <= MAX_NUM_SBG_SIG_HIRES, "ASPX", "Calculated A-SPX stop subband group (aspx_sbg_stop) exceeds maximum number of A-SPX subband groups.");
+
+    /* Reset all envelope values below aspx_sbg_start. */
+    for (sbg = 0; sbg < aspx_sbg_start; sbg++)
+    {
+        p_sine_start_env[sbg] = MAX_NUM_ATSG_SIG;
+    }
+
+    /* Loop over subband groups within active A-SPX range */
+    for (; sbg < aspx_sbg_stop; sbg++)
+    {
+        /* sine to be added in current subband group */
+        if (ADD_HARMONIC(aspx_add_harmonic, sbg - aspx_sbg_start))
+        {
+            /* Sine starts at the first envelope when
+               - there is no transient envelope
+               - or a sine was present in previous frame's subband group */
+            if (aspx_tsg_ptr == -1 || p_sine_start_env[sbg] != MAX_NUM_ATSG_SIG)
+            {
+                p_sine_start_env[sbg] = 0;
+            }
+            /* sine starts at envelope indicated by pointer */
+            else
+            {
+                p_sine_start_env[sbg] = aspx_tsg_ptr;
+            }
+        }
+        /* no sine present */
+        else
+        {
+            p_sine_start_env[sbg] = MAX_NUM_ATSG_SIG;
+        }
+    }
+
+    /* Reset all envelope values above num_sbg_sig_hires up to the max. */
+    for (; sbg < MAX_NUM_SBG_SIG_HIRES; sbg++)
+    {
+        p_sine_start_env[sbg] = MAX_NUM_ATSG_SIG;
+    }
+}
+
+
+/*
+ * Determines if the frame is complete and can be decoded.
+ * This information is essential for EHFR modes, where one frame consists of multiple slices. For the non-EHFR mode the return
+ * value (b_frame_complete) is always 1.
+ */
+static inline int
+function_c_aux
+    (unsigned int              sequence_counter               /* [in] Sequence counter. */
+    ,unsigned int              frame_rate_fraction            /* [in] Frame rate fraction. */
+    ,cch_config_change_t       config_change                  /* [in] Configuration change. */
+    ,unsigned int             *p_num_slices_available         /* [in,out] Slice counter holding the number of available slices.
+                                                                          This variable is updated within this function. */
+    ,int                      *pb_dropped_first_slice         /* [out] Flag indicating that the first slice of an EHFR frame
+                                                                       has been dropped. */
+    )
+{
+    const unsigned int max_slice_index = frame_rate_fraction - 1;
+
+    *pb_dropped_first_slice = 0;
+
+    /* reset number of slices */
+    if (    ((sequence_counter & max_slice_index) == 0)
+         || (SPLICE == GET_CONFIG_EVENT(config_change))
+       )
+    {
+        *p_num_slices_available = 0;
+    }
+    else if (FRAME_DROP == GET_FRAME_EVENT(config_change))
+    {
+        /* check if the start frame was dropped */
+        if (((sequence_counter - 1) & max_slice_index) == 0)
+        {
+            *p_num_slices_available = 0;
+
+            if (frame_rate_fraction > 1)
+            {
+                /* For frame rate fraction values greater than one, the decoder shall process an output frame.
+                   Therefore, we count the dropped frames as well. The decoder is supposed to conceal for an incomplete frame,
+                   which results in silence at the output. */
+                *p_num_slices_available = 1;
+                *pb_dropped_first_slice = 1;
+            }
+        }
+        else
+        {
+            ++(*p_num_slices_available);
+        }
+    }
+
+    return ++(*p_num_slices_available) == frame_rate_fraction;
+}
+
+/*
+ * Determines and assigns data to the frame data structure which exists for every single frame and is stored in the internal FIFO
+ * buffer. Moreover, the config_change message is complemented with a frame event (FRAME_DROP or FRAME_REPETITION).
+ * Note that short frame equivalents - as used for frame length information - means, that e.g. a long frame has the length of 4.
+ */
+int
+function_c
+    (int                       b_collection_frame_previous    /* [in] Flag indicating if the previous frame was a collection
+                                                                      frame. */
+    ,unsigned int              sequence_counter_current       /* [in] Sequence counter of current frame. */
+    ,unsigned int              frame_rate_fraction_previous   /* [in] Frame rate fraction of previous frame. */
+    ,unsigned int              frame_rate_fraction_current    /* [in] Frame rate fraction of current frame. */
+    ,unsigned int              length_frame_delayed           /* [in] Length of the delayed frame in units of short frame
+                                                                      equivalents. */
+    ,unsigned int              length_frame_current           /* [in] Length of the current frame in units of short frame
+                                                                      equivalents. */
+    ,cch_config_change_t      *p_config_change                /* [in,out] Configuration change. */
+    ,unsigned int             *p_length_frames_collected      /* [in,out] Stores the overall length of collected frames in units of
+                                                                          short frame equivalents.
+                                                                          This variable is updated within this function. */
+    ,unsigned int             *p_num_frames_collected         /* [in,out] Stores the number of collected frames during a
+                                                                          collection phase.
+                                                                          This variable is updated within this function. */
+    ,unsigned int             *p_num_slices_available         /* [in,out] Slice counter holding the number of available slices.
+                                                                          This variable is updated within this function. */
+    ,cch_config_change_t      *p_config_change_previous       /* [out] Config change of previous frame. */
+    ,cch_frame_data_t         *p_frame_data_current           /* [out] Frame data structure to be filled. */
+    )
+{
+    const unsigned int max_slice_index_previous  = frame_rate_fraction_previous - 1;
+    const unsigned int max_slice_index_current   = frame_rate_fraction_current - 1;
+    const unsigned int sequence_counter_previous = sequence_counter_current - 1;
+    const unsigned int slice_index_previous      = cch_get_slice_index(sequence_counter_previous, frame_rate_fraction_previous);
+    const unsigned int slice_index_current       = cch_get_slice_index(sequence_counter_current, frame_rate_fraction_current);
+    int                b_dropped_last_slice      = 0;
+    int                b_dropped_first_slice;
+
+    /* reset frame length collector variable in case of splice */
+    if (    (SPLICE == GET_CONFIG_EVENT(*p_config_change))
+         || (    (FRAME_DROP == GET_FRAME_EVENT(*p_config_change))
+              && (!b_collection_frame_previous)
+              && (0 == (sequence_counter_current & max_slice_index_current))
+            ) /* frame drop at last slice of previous frame */
+       )
+    {
+        *p_length_frames_collected = 0;
+    }
+
+    /* reset collection frame counter variable */
+    if (0 == *p_length_frames_collected)
+    {
+        *p_num_frames_collected = 0;
+    }
+
+    if (FRAME_REPETITION == GET_FRAME_EVENT(*p_config_change))
+    {
+        p_frame_data_current->b_frame_complete   = frame_rate_fraction_current == 1;
+        p_frame_data_current->b_collection_frame = (length_frame_delayed > length_frame_current) ? 1 : b_collection_frame_previous;
+
+        p_frame_data_current->config_change = *p_config_change; /* assign config change message */
+
+        return 0;
+    }
+
+    /* determine and assign frame completion flag */
+    p_frame_data_current->b_frame_complete = function_c_aux
+        (sequence_counter_current
+        ,frame_rate_fraction_current
+        ,*p_config_change
+        ,p_num_slices_available
+        ,&b_dropped_first_slice
+        );
+
+    /* determine collection frame flag */
+    if (1 == (*p_num_slices_available - b_dropped_first_slice))
+    {
+        /* increase the frame length counter only if there is a decodable frame available */
+        *p_length_frames_collected += length_frame_current;
+        (*p_num_frames_collected)++;
+    }
+
+    /* determine completion flag */
+    p_frame_data_current->b_collection_frame = *p_length_frames_collected < length_frame_delayed;
+
+    if (    (!p_frame_data_current->b_collection_frame)
+         && (p_frame_data_current->b_frame_complete)
+       )
+    {
+        /* On exit of the collection phase, the overall collection frame length is reset.
+           Note, that the number of collected frames (num_frames_collected) is needed later on. Hence this variable is reset when
+           entering this function. */
+        *p_length_frames_collected = 0;
+    }
+
+    if (FRAME_DROP == GET_FRAME_EVENT(*p_config_change))
+    {
+        /* mark an EHFR frame as dropped */
+        if (    (frame_rate_fraction_current > 1)
+             && (frame_rate_fraction_previous > 1)
+           ) /* previous and current frame are EHFR frames */
+        {
+            SET_FRAME_EVENT(*p_config_change, FRAME_DROP);
+
+            if (slice_index_previous == max_slice_index_previous)
+            {
+                b_dropped_last_slice = 1;
+            }
+        }
+        else if (    (1 == frame_rate_fraction_current)
+                  && (frame_rate_fraction_previous > 1)
+                  && (slice_index_previous < max_slice_index_previous)
+                ) /* current frame is self-contained */
+        {
+            SET_FRAME_EVENT(*p_config_change_previous, FRAME_DROP);
+        }
+        else if (    (frame_rate_fraction_current > 1)
+                  && (1 == frame_rate_fraction_previous)
+                  && (slice_index_current > 0)
+                ) /* previous frame was self-contained */
+        {
+            SET_FRAME_EVENT(*p_config_change, FRAME_DROP);
+        }
+    }
+
+    p_frame_data_current->config_change = *p_config_change; /* assign config change message */
+    return b_dropped_last_slice;
+}
-- 
2.34.1

